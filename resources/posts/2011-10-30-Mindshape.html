<article comments="1">
  <title>Mindshape</title>
  <date>2011-10-30 19:45</date>
  <tags>
    <tag>Technology</tag>
  </tags>
</article>

<summary>
  <p>
    There has been four programming languages (or language families,
    in case of two) that shaped my career, that changed the way I
    think, the way I work.
  </p>

  <p>
    These
    were <a href="http://en.wikipedia.org/wiki/Commodore_BASIC">C+4
    Basic</a>, <a href="http://en.wikipedia.org/wiki/Turbo_Pascal">Pascal</a>,
    <a href="http://en.wikipedia.org/wiki/C_(programming_language)">C</a>
    and <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>.
  </p>
</summary>

<section>
  <p>
    <a href="http://en.wikipedia.org/wiki/Commodore_BASIC">Commodore
    Basic</a> was my first language, I wrote my first few programs in
    it, even before I was able to write human languages. I still
    remember my very first program I wrote together with my father,
    and to this day, I'm very proud of it, however simple it might
    have been.
  </p>

  <p>
    I dabbled in Basic for a while, as that was the only accessible
    language for me at the time. I could have learned assembly, but
    there were no books in Hungarian on Commodore Assembly - nor could
    I afford one, anyway.
  </p>

  <p>
    Years later, when we got our first PC, I still played with Basic,
    but
    neither <a href="http://en.wikipedia.org/wiki/Gwbasic">GW-BASIC</a>,
    nor <a href="http://en.wikipedia.org/wiki/QBasic">QBasic</a> was
    as much joy to work with than what I was expecting, coming from a
    <a href="http://en.wikipedia.org/wiki/Commodore_Plus_4">Commodore
    Plus/4</a>.
  </p>

  <p>
    At one point, I stumbled
    upon <a href="http://en.wikipedia.org/wiki/Turbo_Pascal">Turbo
    Pascal</a>, and noticed that it came with not only example
    programs, but a help system that was so complete and exhaustive,
    that it took half a decade for me to find a similarly well
    documented <a href="http://www.gnu.org/software/emacs/">environment</a>. I
    didn't find the language all that
    great, <a href="http://en.wikipedia.org/wiki/Pointer_(computing)">pointers</a>
    drived me nuts at the time, and the string type I found awkward
    even back then.
  </p>

  <p>
    Even though I've been introduced
    to <a href="http://en.wikipedia.org/wiki/C_(programming_language)">C</a>
    at around 1993 or so, I didn't like it. I was happy with Pascal,
    and just didn't see the value in another language yet.
  </p>

  <p>
    Fast forward to 1996, my computer crashes, and everything I've
    ever done gets destroyed. Not happy. So much so, that I installed
    <a href="http://www.suse.com/">SuSE Linux</a> in anger.
  </p>

  <p>
    I first met <a href="http://www.perl.org/">Perl</a> there, and
    while it did have a strong influence on me, it's nowhere near the
    other four. The major thing I did learn from Perl first, is it's
    motto: <em>There's more than one way to do it</em>.
  </p>

  <p>
    After Perl,
    came <a href="http://en.wikipedia.org/wiki/C_(programming_language)">C</a>
    again. This time, I had a ton of source code at hand, that I could
    learn from, and I had the desire to do so, because I had programs
    written in the language, and bugs in them waiting to be fixed,
    biting me every second day.
  </p>

  <p>
    This is the time when I really learned how to program a
    computer. I dug into C code, and saw it's simplicity, it's
    power. And suprisingly, I found an old, dusty book on the shelves,
    titled <a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">The
    C Programming Language</a> - thought I'll go ahead and read it.
  </p>

  <p>
    I didn't have much success with computer books in the past: they
    were either too dry, too hard, or gave too little information. I
    wasn't expecting much else
    from <a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">The
    K&R</a>, either.
  </p>

  <p>
    Boy, was I suprised! I couldn't put the book down. The style, the
    examples... I was astounded. I never knew one could write a
    technical book of this quality.
  </p>

  <p>
    This book, and the language pretty much reshaped my whole
    knowledge of programming. I learned
    what <a href="http://en.wikipedia.org/wiki/Pointer_(computing)">pointers</a>
    are good for, learned memory management, threading, locks and all
    kinds of stuff over the years, all in C.
  </p>

  <p>
    Suprisingly, it was also C that thaught me object-oriented
    programming. I met with OOP in Pascal and Perl too, wrote units,
    modules and whatnot on my own, but I never quite grasped the
    concept.
  </p>

  <p>
    Not until I played a little
    with <a href="http://www.gtk.org/">GTK+</a>. Things suddenly
    started to make sense, the pieces finally fell into place.
  </p>

  <p>I was happy.</p>

  <p>
    Around this time, I switched editors, and started using
    <a href="http://www.gnu.org/software/emacs/">Emacs</a>, which
    happened to be mostly written in a language
    called <a href="http://en.wikipedia.org/wiki/Emacs_lisp">Emacs
    Lisp</a>, which looked very, very strange at first with all its
    parentheses.
  </p>

  <p>
    It took me more than a decade to learn to appreciate the language,
    and I needed a brief affair
    with <a href="http://haskell.org/">Haskell</a>, and a read of the
    <a href="http://learnyouahaskell.com/">LYAH</a> to realize what
    power Lisp has.
  </p>

  <p>
    Accidentally, the <a href="http://learnyouahaskell.com/">LYAH</a>
    is the second programming book I ever read from page one to the
    last, and enjoyed all of it (the first one obviously being
    the <a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">K&R</a>). It
    was enlightening.
  </p>

  <p>
    But even though Haskell was an interesting language, I did not end
    up loving it. I admired its pure functionality, but it just didn't
    seem practical, and I found the language to be.. a bit too
    verbose. And I seem to remember a few things annoying me at the
    time I was toying with it.
  </p>

  <p>
    However, Haskell was the first functional language I studied, and
    that brought me back to Lisp
    (it's <a href="http://clojure.org/">Clojure</a> dialect, to be
    precise): I realized that the **code is data** mantra is actually
    really, really, really powerful.
  </p>

  <p>
    That, and a language that's already familiar from my editor,
    strives to be functional, but not at the expense of practicality,
    has great interoperability with existing technology (the JVM) is
    the perfect match for me.
  </p>

  <p>
    Since I started writing <a href="http://clojure.org/">Clojure</a>
    code, I finally feel at home. Suprisingly, it also affects the C
    code I write, in a good way:  functional programming (via Clojure)
    taught me how to write well-composable code. Code that is clear,
    understandable, and plays well with the rest of the codebase.
  </p>

  <p>
    As C changed the way I think, so did Lisp, and to this day, I
    cannot be thankful enough to be able to use both on a daily
    basis. Which other language can say this? That they've been with
    us for nearly half a century (or in Lisp's case, even more), and
    are still in use today, one way or the other? That to this day,
    their influence can still be seen in almost every other major
    language.
  </p>

  <p>
    And what triggered this article? Bad news, sadly.
  </p>

  <p>
    On the 12nd of October, the father
    of <a href="http://en.wikipedia.org/wiki/C_(programming_language)">C</a>,
    <a href="http://en.wikipedia.org/wiki/Unix">UNIX</a>, <a href="http://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis
    Ritchie</a> passed away, and on the 23rd,
    the <a href="http://paulgraham.com/rootsoflisp.html">discoverer of
    Lisp</a>, the father of Artificial
    Intelligence, <a href="http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John
    McCarthy</a> died aswell.
  </p>

  <p>
    October's a sad month.
  </p>

  <pre class="prettyprint lang-c">#include &lt;stdio.h&gt;

/*
 * $ cc goodbye.c &amp;&amp; ./a.out | clojure -
 * Goodbye, Father
 */

int main (void) {
	printf ("(println \"Goodbye, Father\")\n");
	return 0;
}</pre>
</section>
